/* tslint:disable */
/* eslint-disable */
/**
 * backend
 * Payload project created from blog template
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration"
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios"
import globalAxios from "axios"
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common"
import type { RequestArgs } from "./base"
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from "./base"

/**
 *
 * @export
 * @interface Access
 */
export interface Access {
  /**
   *
   * @type {boolean}
   * @memberof Access
   */
  canAccessAdmin: boolean
  /**
   *
   * @type {{ [key: string]: AccessCollectionsValue; }}
   * @memberof Access
   */
  collections: { [key: string]: AccessCollectionsValue }
}
/**
 *
 * @export
 * @interface AccessCollectionsValue
 */
export interface AccessCollectionsValue {
  /**
   *
   * @type {AccessCollectionsValueCreate}
   * @memberof AccessCollectionsValue
   */
  create: AccessCollectionsValueCreate
  /**
   *
   * @type {AccessCollectionsValueCreate}
   * @memberof AccessCollectionsValue
   */
  read: AccessCollectionsValueCreate
  /**
   *
   * @type {AccessCollectionsValueCreate}
   * @memberof AccessCollectionsValue
   */
  update: AccessCollectionsValueCreate
  /**
   *
   * @type {AccessCollectionsValueCreate}
   * @memberof AccessCollectionsValue
   */
  delete: AccessCollectionsValueCreate
  /**
   *
   * @type {{ [key: string]: AccessCollectionsValueFieldsValue; }}
   * @memberof AccessCollectionsValue
   */
  fields: { [key: string]: AccessCollectionsValueFieldsValue }
}
/**
 *
 * @export
 * @interface AccessCollectionsValueCreate
 */
export interface AccessCollectionsValueCreate {
  /**
   *
   * @type {boolean}
   * @memberof AccessCollectionsValueCreate
   */
  permission: boolean
}
/**
 *
 * @export
 * @interface AccessCollectionsValueFieldsValue
 */
export interface AccessCollectionsValueFieldsValue {
  /**
   *
   * @type {AccessCollectionsValueCreate}
   * @memberof AccessCollectionsValueFieldsValue
   */
  create: AccessCollectionsValueCreate
  /**
   *
   * @type {AccessCollectionsValueCreate}
   * @memberof AccessCollectionsValueFieldsValue
   */
  read: AccessCollectionsValueCreate
  /**
   *
   * @type {AccessCollectionsValueCreate}
   * @memberof AccessCollectionsValueFieldsValue
   */
  update: AccessCollectionsValueCreate
}
/**
 *
 * @export
 * @interface Confirmation
 */
export interface Confirmation {
  /**
   *
   * @type {string}
   * @memberof Confirmation
   */
  message: string
}
/**
 *
 * @export
 * @interface ErrorErrorsInner
 */
export interface ErrorErrorsInner {
  /**
   *
   * @type {string}
   * @memberof ErrorErrorsInner
   */
  message: string
}
/**
 *
 * @export
 * @interface Frontpage
 */
export interface Frontpage {
  /**
   *
   * @type {string}
   * @memberof Frontpage
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof Frontpage
   */
  about?: string
  /**
   *
   * @type {PostsPostImage}
   * @memberof Frontpage
   */
  aboutImage?: PostsPostImage
  /**
   *
   * @type {Array<FrontpageFeaturesInner>}
   * @memberof Frontpage
   */
  features?: Array<FrontpageFeaturesInner>
  /**
   *
   * @type {string}
   * @memberof Frontpage
   */
  updatedAt?: string
  /**
   *
   * @type {string}
   * @memberof Frontpage
   */
  createdAt?: string
}
/**
 *
 * @export
 * @interface FrontpageFeaturesInner
 */
export interface FrontpageFeaturesInner {
  /**
   *
   * @type {string}
   * @memberof FrontpageFeaturesInner
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof FrontpageFeaturesInner
   */
  content: string
  /**
   *
   * @type {string}
   * @memberof FrontpageFeaturesInner
   */
  id?: string
}
/**
 *
 * @export
 * @interface FrontpageUpsertConfirmation
 */
export interface FrontpageUpsertConfirmation {
  /**
   *
   * @type {Frontpage}
   * @memberof FrontpageUpsertConfirmation
   */
  doc: Frontpage
  /**
   *
   * @type {string}
   * @memberof FrontpageUpsertConfirmation
   */
  message: string
}
/**
 *
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
  /**
   *
   * @type {string}
   * @memberof LoginRequest
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof LoginRequest
   */
  password: string
}
/**
 *
 * @export
 * @interface Media
 */
export interface Media {
  /**
   *
   * @type {string}
   * @memberof Media
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof Media
   */
  alt?: string
  /**
   *
   * @type {string}
   * @memberof Media
   */
  updatedAt: string
  /**
   *
   * @type {string}
   * @memberof Media
   */
  createdAt: string
  /**
   *
   * @type {string}
   * @memberof Media
   */
  url?: string
  /**
   *
   * @type {string}
   * @memberof Media
   */
  filename?: string
  /**
   *
   * @type {string}
   * @memberof Media
   */
  mimeType?: string
  /**
   *
   * @type {number}
   * @memberof Media
   */
  filesize?: number
  /**
   *
   * @type {number}
   * @memberof Media
   */
  width?: number
  /**
   *
   * @type {number}
   * @memberof Media
   */
  height?: number
  /**
   *
   * @type {MediaSizes}
   * @memberof Media
   */
  sizes?: MediaSizes
}
/**
 *
 * @export
 * @interface MediaDelete200Response
 */
export interface MediaDelete200Response {
  /**
   *
   * @type {string}
   * @memberof MediaDelete200Response
   */
  message?: string
  /**
   *
   * @type {Array<string>}
   * @memberof MediaDelete200Response
   */
  errors?: Array<string>
  /**
   *
   * @type {Array<Media>}
   * @memberof MediaDelete200Response
   */
  docs?: Array<Media>
}
/**
 *
 * @export
 * @interface MediaSizes
 */
export interface MediaSizes {
  /**
   *
   * @type {MediaSizesThumbnail}
   * @memberof MediaSizes
   */
  thumbnail?: MediaSizesThumbnail
  /**
   *
   * @type {MediaSizesThumbnail}
   * @memberof MediaSizes
   */
  sixteenByNineMedium?: MediaSizesThumbnail
}
/**
 *
 * @export
 * @interface MediaSizesThumbnail
 */
export interface MediaSizesThumbnail {
  /**
   *
   * @type {string}
   * @memberof MediaSizesThumbnail
   */
  url?: string
  /**
   *
   * @type {number}
   * @memberof MediaSizesThumbnail
   */
  width?: number
  /**
   *
   * @type {number}
   * @memberof MediaSizesThumbnail
   */
  height?: number
  /**
   *
   * @type {string}
   * @memberof MediaSizesThumbnail
   */
  mimeType?: string
  /**
   *
   * @type {number}
   * @memberof MediaSizesThumbnail
   */
  filesize?: number
  /**
   *
   * @type {string}
   * @memberof MediaSizesThumbnail
   */
  filename?: string
}
/**
 *
 * @export
 * @interface MediaUpsertConfirmation
 */
export interface MediaUpsertConfirmation {
  /**
   *
   * @type {Media}
   * @memberof MediaUpsertConfirmation
   */
  doc: Media
  /**
   *
   * @type {string}
   * @memberof MediaUpsertConfirmation
   */
  message: string
}
/**
 *
 * @export
 * @interface Medias
 */
export interface Medias {
  /**
   *
   * @type {Array<Media>}
   * @memberof Medias
   */
  docs: Array<Media>
  /**
   *
   * @type {number}
   * @memberof Medias
   */
  totalDocs: number
  /**
   *
   * @type {number}
   * @memberof Medias
   */
  limit: number
  /**
   *
   * @type {number}
   * @memberof Medias
   */
  totalPages: number
  /**
   *
   * @type {number}
   * @memberof Medias
   */
  page: number
  /**
   *
   * @type {number}
   * @memberof Medias
   */
  pagingCounter: number
  /**
   *
   * @type {boolean}
   * @memberof Medias
   */
  hasPrevPage: boolean
  /**
   *
   * @type {boolean}
   * @memberof Medias
   */
  hasNextPage: boolean
  /**
   *
   * @type {number}
   * @memberof Medias
   */
  prevPage?: number
  /**
   *
   * @type {number}
   * @memberof Medias
   */
  nextPage?: number
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {Array<ErrorErrorsInner>}
   * @memberof ModelError
   */
  errors: Array<ErrorErrorsInner>
}
/**
 *
 * @export
 * @interface Posts
 */
export interface Posts {
  /**
   *
   * @type {string}
   * @memberof Posts
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof Posts
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof Posts
   */
  description: string
  /**
   *
   * @type {string}
   * @memberof Posts
   */
  keywords?: string
  /**
   *
   * @type {PostsPostImage}
   * @memberof Posts
   */
  postImage: PostsPostImage
  /**
   *
   * @type {Array<object>}
   * @memberof Posts
   */
  content?: Array<object>
  /**
   *
   * @type {string}
   * @memberof Posts
   */
  status?: PostsStatusEnum
  /**
   *
   * @type {string}
   * @memberof Posts
   */
  publishedDate?: string
  /**
   *
   * @type {PostsAuthor}
   * @memberof Posts
   */
  author?: PostsAuthor
  /**
   *
   * @type {string}
   * @memberof Posts
   */
  updatedAt: string
  /**
   *
   * @type {string}
   * @memberof Posts
   */
  createdAt: string
}

export const PostsStatusEnum = {
  Draft: "draft",
  Published: "published",
} as const

export type PostsStatusEnum = (typeof PostsStatusEnum)[keyof typeof PostsStatusEnum]

/**
 * @type PostsAuthor
 * @export
 */
export type PostsAuthor = Users | string

/**
 *
 * @export
 * @interface PostsDelete200Response
 */
export interface PostsDelete200Response {
  /**
   *
   * @type {string}
   * @memberof PostsDelete200Response
   */
  message?: string
  /**
   *
   * @type {Array<string>}
   * @memberof PostsDelete200Response
   */
  errors?: Array<string>
  /**
   *
   * @type {Array<Posts>}
   * @memberof PostsDelete200Response
   */
  docs?: Array<Posts>
}
/**
 * @type PostsPostImage
 * @export
 */
export type PostsPostImage = Media | string

/**
 *
 * @export
 * @interface PostsUpsertConfirmation
 */
export interface PostsUpsertConfirmation {
  /**
   *
   * @type {Posts}
   * @memberof PostsUpsertConfirmation
   */
  doc: Posts
  /**
   *
   * @type {string}
   * @memberof PostsUpsertConfirmation
   */
  message: string
}
/**
 *
 * @export
 * @interface Postss
 */
export interface Postss {
  /**
   *
   * @type {Array<Posts>}
   * @memberof Postss
   */
  docs: Array<Posts>
  /**
   *
   * @type {number}
   * @memberof Postss
   */
  totalDocs: number
  /**
   *
   * @type {number}
   * @memberof Postss
   */
  limit: number
  /**
   *
   * @type {number}
   * @memberof Postss
   */
  totalPages: number
  /**
   *
   * @type {number}
   * @memberof Postss
   */
  page: number
  /**
   *
   * @type {number}
   * @memberof Postss
   */
  pagingCounter: number
  /**
   *
   * @type {boolean}
   * @memberof Postss
   */
  hasPrevPage: boolean
  /**
   *
   * @type {boolean}
   * @memberof Postss
   */
  hasNextPage: boolean
  /**
   *
   * @type {number}
   * @memberof Postss
   */
  prevPage?: number
  /**
   *
   * @type {number}
   * @memberof Postss
   */
  nextPage?: number
}
/**
 *
 * @export
 * @interface Profiles
 */
export interface Profiles {
  /**
   *
   * @type {string}
   * @memberof Profiles
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof Profiles
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof Profiles
   */
  description: string
  /**
   *
   * @type {ProfilesSkills}
   * @memberof Profiles
   */
  skills?: ProfilesSkills
  /**
   *
   * @type {string}
   * @memberof Profiles
   */
  updatedAt: string
  /**
   *
   * @type {string}
   * @memberof Profiles
   */
  createdAt: string
}
/**
 *
 * @export
 * @interface ProfilesDelete200Response
 */
export interface ProfilesDelete200Response {
  /**
   *
   * @type {string}
   * @memberof ProfilesDelete200Response
   */
  message?: string
  /**
   *
   * @type {Array<string>}
   * @memberof ProfilesDelete200Response
   */
  errors?: Array<string>
  /**
   *
   * @type {Array<Profiles>}
   * @memberof ProfilesDelete200Response
   */
  docs?: Array<Profiles>
}
/**
 * @type ProfilesSkills
 * @export
 */
export type ProfilesSkills = Array<Skills> | Array<string>

/**
 *
 * @export
 * @interface ProfilesUpsertConfirmation
 */
export interface ProfilesUpsertConfirmation {
  /**
   *
   * @type {Profiles}
   * @memberof ProfilesUpsertConfirmation
   */
  doc: Profiles
  /**
   *
   * @type {string}
   * @memberof ProfilesUpsertConfirmation
   */
  message: string
}
/**
 *
 * @export
 * @interface Profiless
 */
export interface Profiless {
  /**
   *
   * @type {Array<Profiles>}
   * @memberof Profiless
   */
  docs: Array<Profiles>
  /**
   *
   * @type {number}
   * @memberof Profiless
   */
  totalDocs: number
  /**
   *
   * @type {number}
   * @memberof Profiless
   */
  limit: number
  /**
   *
   * @type {number}
   * @memberof Profiless
   */
  totalPages: number
  /**
   *
   * @type {number}
   * @memberof Profiless
   */
  page: number
  /**
   *
   * @type {number}
   * @memberof Profiless
   */
  pagingCounter: number
  /**
   *
   * @type {boolean}
   * @memberof Profiless
   */
  hasPrevPage: boolean
  /**
   *
   * @type {boolean}
   * @memberof Profiless
   */
  hasNextPage: boolean
  /**
   *
   * @type {number}
   * @memberof Profiless
   */
  prevPage?: number
  /**
   *
   * @type {number}
   * @memberof Profiless
   */
  nextPage?: number
}
/**
 *
 * @export
 * @interface Skills
 */
export interface Skills {
  /**
   *
   * @type {string}
   * @memberof Skills
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof Skills
   */
  name?: string
}
/**
 *
 * @export
 * @interface SkillsDelete200Response
 */
export interface SkillsDelete200Response {
  /**
   *
   * @type {string}
   * @memberof SkillsDelete200Response
   */
  message?: string
  /**
   *
   * @type {Array<string>}
   * @memberof SkillsDelete200Response
   */
  errors?: Array<string>
  /**
   *
   * @type {Array<Skills>}
   * @memberof SkillsDelete200Response
   */
  docs?: Array<Skills>
}
/**
 *
 * @export
 * @interface SkillsUpsertConfirmation
 */
export interface SkillsUpsertConfirmation {
  /**
   *
   * @type {Skills}
   * @memberof SkillsUpsertConfirmation
   */
  doc: Skills
  /**
   *
   * @type {string}
   * @memberof SkillsUpsertConfirmation
   */
  message: string
}
/**
 *
 * @export
 * @interface Skillss
 */
export interface Skillss {
  /**
   *
   * @type {Array<Skills>}
   * @memberof Skillss
   */
  docs: Array<Skills>
  /**
   *
   * @type {number}
   * @memberof Skillss
   */
  totalDocs: number
  /**
   *
   * @type {number}
   * @memberof Skillss
   */
  limit: number
  /**
   *
   * @type {number}
   * @memberof Skillss
   */
  totalPages: number
  /**
   *
   * @type {number}
   * @memberof Skillss
   */
  page: number
  /**
   *
   * @type {number}
   * @memberof Skillss
   */
  pagingCounter: number
  /**
   *
   * @type {boolean}
   * @memberof Skillss
   */
  hasPrevPage: boolean
  /**
   *
   * @type {boolean}
   * @memberof Skillss
   */
  hasNextPage: boolean
  /**
   *
   * @type {number}
   * @memberof Skillss
   */
  prevPage?: number
  /**
   *
   * @type {number}
   * @memberof Skillss
   */
  nextPage?: number
}
/**
 *
 * @export
 * @interface Users
 */
export interface Users {
  /**
   *
   * @type {string}
   * @memberof Users
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof Users
   */
  name?: string
  /**
   *
   * @type {Array<string>}
   * @memberof Users
   */
  roles?: Array<UsersRolesEnum>
  /**
   *
   * @type {string}
   * @memberof Users
   */
  updatedAt: string
  /**
   *
   * @type {string}
   * @memberof Users
   */
  createdAt: string
  /**
   *
   * @type {string}
   * @memberof Users
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof Users
   */
  resetPasswordToken?: string
  /**
   *
   * @type {string}
   * @memberof Users
   */
  resetPasswordExpiration?: string
  /**
   *
   * @type {string}
   * @memberof Users
   */
  salt?: string
  /**
   *
   * @type {string}
   * @memberof Users
   */
  hash?: string
  /**
   *
   * @type {number}
   * @memberof Users
   */
  loginAttempts?: number
  /**
   *
   * @type {string}
   * @memberof Users
   */
  lockUntil?: string
  /**
   *
   * @type {string}
   * @memberof Users
   */
  password: string
}

export const UsersRolesEnum = {
  Admin: "admin",
  Editor: "editor",
} as const

export type UsersRolesEnum = (typeof UsersRolesEnum)[keyof typeof UsersRolesEnum]

/**
 *
 * @export
 * @interface UsersDelete200Response
 */
export interface UsersDelete200Response {
  /**
   *
   * @type {string}
   * @memberof UsersDelete200Response
   */
  message?: string
  /**
   *
   * @type {Array<string>}
   * @memberof UsersDelete200Response
   */
  errors?: Array<string>
  /**
   *
   * @type {Array<Users>}
   * @memberof UsersDelete200Response
   */
  docs?: Array<Users>
}
/**
 *
 * @export
 * @interface UsersMe
 */
export interface UsersMe {
  /**
   *
   * @type {Users}
   * @memberof UsersMe
   */
  user: Users
  /**
   *
   * @type {string}
   * @memberof UsersMe
   */
  token?: string
  /**
   *
   * @type {number}
   * @memberof UsersMe
   */
  exp?: number
}
/**
 *
 * @export
 * @interface UsersUnlockPostRequest
 */
export interface UsersUnlockPostRequest {
  /**
   *
   * @type {string}
   * @memberof UsersUnlockPostRequest
   */
  email: string
}
/**
 *
 * @export
 * @interface UsersUpsertConfirmation
 */
export interface UsersUpsertConfirmation {
  /**
   *
   * @type {Users}
   * @memberof UsersUpsertConfirmation
   */
  doc: Users
  /**
   *
   * @type {string}
   * @memberof UsersUpsertConfirmation
   */
  message: string
}
/**
 *
 * @export
 * @interface Userss
 */
export interface Userss {
  /**
   *
   * @type {Array<Users>}
   * @memberof Userss
   */
  docs: Array<Users>
  /**
   *
   * @type {number}
   * @memberof Userss
   */
  totalDocs: number
  /**
   *
   * @type {number}
   * @memberof Userss
   */
  limit: number
  /**
   *
   * @type {number}
   * @memberof Userss
   */
  totalPages: number
  /**
   *
   * @type {number}
   * @memberof Userss
   */
  page: number
  /**
   *
   * @type {number}
   * @memberof Userss
   */
  pagingCounter: number
  /**
   *
   * @type {boolean}
   * @memberof Userss
   */
  hasPrevPage: boolean
  /**
   *
   * @type {boolean}
   * @memberof Userss
   */
  hasNextPage: boolean
  /**
   *
   * @type {number}
   * @memberof Userss
   */
  prevPage?: number
  /**
   *
   * @type {number}
   * @memberof Userss
   */
  nextPage?: number
}
/**
 *
 * @export
 * @interface Where
 */
export interface Where {
  [key: string]: WhereClause | any

  /**
   *
   * @type {Array<Where>}
   * @memberof Where
   */
  or?: Array<Where>
  /**
   *
   * @type {Array<Where>}
   * @memberof Where
   */
  and?: Array<Where>
}
/**
 *
 * @export
 * @interface WhereClause
 */
export interface WhereClause {
  /**
   *
   * @type {any}
   * @memberof WhereClause
   */
  equals?: any
  /**
   *
   * @type {any}
   * @memberof WhereClause
   */
  not_equals?: any
  /**
   *
   * @type {WhereClauseAnyOf2GreaterThan}
   * @memberof WhereClause
   */
  greater_than?: WhereClauseAnyOf2GreaterThan
  /**
   *
   * @type {WhereClauseAnyOf2GreaterThan}
   * @memberof WhereClause
   */
  greater_than_equal?: WhereClauseAnyOf2GreaterThan
  /**
   *
   * @type {WhereClauseAnyOf2GreaterThan}
   * @memberof WhereClause
   */
  less_than?: WhereClauseAnyOf2GreaterThan
  /**
   *
   * @type {WhereClauseAnyOf2GreaterThan}
   * @memberof WhereClause
   */
  less_than_equal?: WhereClauseAnyOf2GreaterThan
  /**
   *
   * @type {string}
   * @memberof WhereClause
   */
  like?: string
  /**
   *
   * @type {string}
   * @memberof WhereClause
   */
  contains?: string
  /**
   *
   * @type {string}
   * @memberof WhereClause
   */
  in?: string
  /**
   *
   * @type {string}
   * @memberof WhereClause
   */
  not_in?: string
  /**
   *
   * @type {boolean}
   * @memberof WhereClause
   */
  exists?: boolean
  /**
   *
   * @type {string}
   * @memberof WhereClause
   */
  near?: string
}
/**
 *
 * @export
 * @interface WhereClauseAnyOf
 */
export interface WhereClauseAnyOf {
  /**
   *
   * @type {any}
   * @memberof WhereClauseAnyOf
   */
  equals?: any
}
/**
 *
 * @export
 * @interface WhereClauseAnyOf1
 */
export interface WhereClauseAnyOf1 {
  /**
   *
   * @type {any}
   * @memberof WhereClauseAnyOf1
   */
  not_equals?: any
}
/**
 *
 * @export
 * @interface WhereClauseAnyOf10
 */
export interface WhereClauseAnyOf10 {
  /**
   *
   * @type {boolean}
   * @memberof WhereClauseAnyOf10
   */
  exists?: boolean
}
/**
 *
 * @export
 * @interface WhereClauseAnyOf11
 */
export interface WhereClauseAnyOf11 {
  /**
   *
   * @type {string}
   * @memberof WhereClauseAnyOf11
   */
  near?: string
}
/**
 *
 * @export
 * @interface WhereClauseAnyOf2
 */
export interface WhereClauseAnyOf2 {
  /**
   *
   * @type {WhereClauseAnyOf2GreaterThan}
   * @memberof WhereClauseAnyOf2
   */
  greater_than?: WhereClauseAnyOf2GreaterThan
}
/**
 *
 * @export
 * @interface WhereClauseAnyOf2GreaterThan
 */
export interface WhereClauseAnyOf2GreaterThan {}
/**
 *
 * @export
 * @interface WhereClauseAnyOf3
 */
export interface WhereClauseAnyOf3 {
  /**
   *
   * @type {WhereClauseAnyOf2GreaterThan}
   * @memberof WhereClauseAnyOf3
   */
  greater_than_equal?: WhereClauseAnyOf2GreaterThan
}
/**
 *
 * @export
 * @interface WhereClauseAnyOf4
 */
export interface WhereClauseAnyOf4 {
  /**
   *
   * @type {WhereClauseAnyOf2GreaterThan}
   * @memberof WhereClauseAnyOf4
   */
  less_than?: WhereClauseAnyOf2GreaterThan
}
/**
 *
 * @export
 * @interface WhereClauseAnyOf5
 */
export interface WhereClauseAnyOf5 {
  /**
   *
   * @type {WhereClauseAnyOf2GreaterThan}
   * @memberof WhereClauseAnyOf5
   */
  less_than_equal?: WhereClauseAnyOf2GreaterThan
}
/**
 *
 * @export
 * @interface WhereClauseAnyOf6
 */
export interface WhereClauseAnyOf6 {
  /**
   *
   * @type {string}
   * @memberof WhereClauseAnyOf6
   */
  like?: string
}
/**
 *
 * @export
 * @interface WhereClauseAnyOf7
 */
export interface WhereClauseAnyOf7 {
  /**
   *
   * @type {string}
   * @memberof WhereClauseAnyOf7
   */
  contains?: string
}
/**
 *
 * @export
 * @interface WhereClauseAnyOf8
 */
export interface WhereClauseAnyOf8 {
  /**
   *
   * @type {string}
   * @memberof WhereClauseAnyOf8
   */
  in?: string
}
/**
 *
 * @export
 * @interface WhereClauseAnyOf9
 */
export interface WhereClauseAnyOf9 {
  /**
   *
   * @type {string}
   * @memberof WhereClauseAnyOf9
   */
  not_in?: string
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Lists the user\'s access per resource
     * @summary Current user\'s resource access
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accessGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/access`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Login
     * @summary Login
     * @param {LoginRequest} [loginRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersLoginPost: async (loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/users/login`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Logout
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersLogoutPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/users/logout`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Data about the current user
     * @summary Current user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/users/me`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Refresh the JWT token
     * @summary Refresh JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersRefreshTokenPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/users/refresh-token`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Unlock account
     * @summary Unlock account
     * @param {UsersUnlockPostRequest} [usersUnlockPostRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersUnlockPost: async (
      usersUnlockPostRequest?: UsersUnlockPostRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/unlock`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(usersUnlockPostRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
  return {
    /**
     * Lists the user\'s access per resource
     * @summary Current user\'s resource access
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accessGet(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Access>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.accessGet(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Login
     * @summary Login
     * @param {LoginRequest} [loginRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersLoginPost(
      loginRequest?: LoginRequest,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersMe>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersLoginPost(loginRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Logout
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersLogoutPost(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Confirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersLogoutPost(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Data about the current user
     * @summary Current user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersMeGet(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersMe>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeGet(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Refresh the JWT token
     * @summary Refresh JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersRefreshTokenPost(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersMe>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersRefreshTokenPost(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Unlock account
     * @summary Unlock account
     * @param {UsersUnlockPostRequest} [usersUnlockPostRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersUnlockPost(
      usersUnlockPostRequest?: UsersUnlockPostRequest,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Confirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersUnlockPost(usersUnlockPostRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AuthApiFp(configuration)
  return {
    /**
     * Lists the user\'s access per resource
     * @summary Current user\'s resource access
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accessGet(options?: AxiosRequestConfig): AxiosPromise<Access> {
      return localVarFp.accessGet(options).then((request) => request(axios, basePath))
    },
    /**
     * Login
     * @summary Login
     * @param {AuthApiUsersLoginPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersLoginPost(
      requestParameters: AuthApiUsersLoginPostRequest = {},
      options?: AxiosRequestConfig
    ): AxiosPromise<UsersMe> {
      return localVarFp
        .usersLoginPost(requestParameters.loginRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Logout
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersLogoutPost(options?: AxiosRequestConfig): AxiosPromise<Confirmation> {
      return localVarFp.usersLogoutPost(options).then((request) => request(axios, basePath))
    },
    /**
     * Data about the current user
     * @summary Current user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersMeGet(options?: AxiosRequestConfig): AxiosPromise<UsersMe> {
      return localVarFp.usersMeGet(options).then((request) => request(axios, basePath))
    },
    /**
     * Refresh the JWT token
     * @summary Refresh JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersRefreshTokenPost(options?: AxiosRequestConfig): AxiosPromise<UsersMe> {
      return localVarFp.usersRefreshTokenPost(options).then((request) => request(axios, basePath))
    },
    /**
     * Unlock account
     * @summary Unlock account
     * @param {AuthApiUsersUnlockPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersUnlockPost(
      requestParameters: AuthApiUsersUnlockPostRequest = {},
      options?: AxiosRequestConfig
    ): AxiosPromise<Confirmation> {
      return localVarFp
        .usersUnlockPost(requestParameters.usersUnlockPostRequest, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for usersLoginPost operation in AuthApi.
 * @export
 * @interface AuthApiUsersLoginPostRequest
 */
export interface AuthApiUsersLoginPostRequest {
  /**
   *
   * @type {LoginRequest}
   * @memberof AuthApiUsersLoginPost
   */
  readonly loginRequest?: LoginRequest
}

/**
 * Request parameters for usersUnlockPost operation in AuthApi.
 * @export
 * @interface AuthApiUsersUnlockPostRequest
 */
export interface AuthApiUsersUnlockPostRequest {
  /**
   *
   * @type {UsersUnlockPostRequest}
   * @memberof AuthApiUsersUnlockPost
   */
  readonly usersUnlockPostRequest?: UsersUnlockPostRequest
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   * Lists the user\'s access per resource
   * @summary Current user\'s resource access
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public accessGet(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .accessGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Login
   * @summary Login
   * @param {AuthApiUsersLoginPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public usersLoginPost(requestParameters: AuthApiUsersLoginPostRequest = {}, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .usersLoginPost(requestParameters.loginRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Logout
   * @summary Logout
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public usersLogoutPost(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .usersLogoutPost(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Data about the current user
   * @summary Current user data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public usersMeGet(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .usersMeGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Refresh the JWT token
   * @summary Refresh JWT
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public usersRefreshTokenPost(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .usersRefreshTokenPost(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Unlock account
   * @summary Unlock account
   * @param {AuthApiUsersUnlockPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public usersUnlockPost(requestParameters: AuthApiUsersUnlockPostRequest = {}, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .usersUnlockPost(requestParameters.usersUnlockPostRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * GlobalFrontpageApi - axios parameter creator
 * @export
 */
export const GlobalFrontpageApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get the Frontpage
     * @summary Get the Frontpage
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    globalsFrontpageGet: async (
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/globals/frontpage`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates the Frontpage
     * @summary Updates the Frontpage
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Frontpage} [frontpage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    globalsFrontpagePost: async (
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      frontpage?: Frontpage,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/globals/frontpage`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(frontpage, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * GlobalFrontpageApi - functional programming interface
 * @export
 */
export const GlobalFrontpageApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GlobalFrontpageApiAxiosParamCreator(configuration)
  return {
    /**
     * Get the Frontpage
     * @summary Get the Frontpage
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async globalsFrontpageGet(
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Frontpage>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.globalsFrontpageGet(
        depth,
        locale,
        fallbackLocale,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Updates the Frontpage
     * @summary Updates the Frontpage
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Frontpage} [frontpage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async globalsFrontpagePost(
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      frontpage?: Frontpage,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontpageUpsertConfirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.globalsFrontpagePost(
        depth,
        locale,
        fallbackLocale,
        frontpage,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * GlobalFrontpageApi - factory interface
 * @export
 */
export const GlobalFrontpageApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = GlobalFrontpageApiFp(configuration)
  return {
    /**
     * Get the Frontpage
     * @summary Get the Frontpage
     * @param {GlobalFrontpageApiGlobalsFrontpageGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    globalsFrontpageGet(
      requestParameters: GlobalFrontpageApiGlobalsFrontpageGetRequest = {},
      options?: AxiosRequestConfig
    ): AxiosPromise<Frontpage> {
      return localVarFp
        .globalsFrontpageGet(
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Updates the Frontpage
     * @summary Updates the Frontpage
     * @param {GlobalFrontpageApiGlobalsFrontpagePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    globalsFrontpagePost(
      requestParameters: GlobalFrontpageApiGlobalsFrontpagePostRequest = {},
      options?: AxiosRequestConfig
    ): AxiosPromise<FrontpageUpsertConfirmation> {
      return localVarFp
        .globalsFrontpagePost(
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.frontpage,
          options
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for globalsFrontpageGet operation in GlobalFrontpageApi.
 * @export
 * @interface GlobalFrontpageApiGlobalsFrontpageGetRequest
 */
export interface GlobalFrontpageApiGlobalsFrontpageGetRequest {
  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof GlobalFrontpageApiGlobalsFrontpageGet
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof GlobalFrontpageApiGlobalsFrontpageGet
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof GlobalFrontpageApiGlobalsFrontpageGet
   */
  readonly fallbackLocale?: string
}

/**
 * Request parameters for globalsFrontpagePost operation in GlobalFrontpageApi.
 * @export
 * @interface GlobalFrontpageApiGlobalsFrontpagePostRequest
 */
export interface GlobalFrontpageApiGlobalsFrontpagePostRequest {
  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof GlobalFrontpageApiGlobalsFrontpagePost
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof GlobalFrontpageApiGlobalsFrontpagePost
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof GlobalFrontpageApiGlobalsFrontpagePost
   */
  readonly fallbackLocale?: string

  /**
   *
   * @type {Frontpage}
   * @memberof GlobalFrontpageApiGlobalsFrontpagePost
   */
  readonly frontpage?: Frontpage
}

/**
 * GlobalFrontpageApi - object-oriented interface
 * @export
 * @class GlobalFrontpageApi
 * @extends {BaseAPI}
 */
export class GlobalFrontpageApi extends BaseAPI {
  /**
   * Get the Frontpage
   * @summary Get the Frontpage
   * @param {GlobalFrontpageApiGlobalsFrontpageGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GlobalFrontpageApi
   */
  public globalsFrontpageGet(
    requestParameters: GlobalFrontpageApiGlobalsFrontpageGetRequest = {},
    options?: AxiosRequestConfig
  ) {
    return GlobalFrontpageApiFp(this.configuration)
      .globalsFrontpageGet(requestParameters.depth, requestParameters.locale, requestParameters.fallbackLocale, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates the Frontpage
   * @summary Updates the Frontpage
   * @param {GlobalFrontpageApiGlobalsFrontpagePostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GlobalFrontpageApi
   */
  public globalsFrontpagePost(
    requestParameters: GlobalFrontpageApiGlobalsFrontpagePostRequest = {},
    options?: AxiosRequestConfig
  ) {
    return GlobalFrontpageApiFp(this.configuration)
      .globalsFrontpagePost(
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.frontpage,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * MediaApi - axios parameter creator
 * @export
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Delete all Media matching the where query
     * @summary Delete multiple Media
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mediaDelete: async (
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'where' is not null or undefined
      assertParamExists("mediaDelete", "where", where)
      const localVarPath = `/media`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Find paginated Media
     * @summary Find paginated Media
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mediaGet: async (
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/media`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deletes an existing Media
     * @summary Deletes an existing Media
     * @param {string} id id of the Media
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mediaIdDelete: async (
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("mediaIdDelete", "id", id)
      const localVarPath = `/media/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get a single Media by its id
     * @summary Get a single Media by its id
     * @param {string} id id of the Media
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mediaIdGet: async (
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("mediaIdGet", "id", id)
      const localVarPath = `/media/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates a Media
     * @summary Updates a Media
     * @param {string} id id of the Media
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Media} [media]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mediaIdPatch: async (
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      media?: Media,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("mediaIdPatch", "id", id)
      const localVarPath = `/media/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(media, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update all Media matching the where query
     * @summary Update multiple Media
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Media} [media]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mediaPatch: async (
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      media?: Media,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'where' is not null or undefined
      assertParamExists("mediaPatch", "where", where)
      const localVarPath = `/media`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(media, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create a new Media
     * @summary Create a new Media
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Media} [media]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mediaPost: async (
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      media?: Media,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/media`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(media, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * MediaApi - functional programming interface
 * @export
 */
export const MediaApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
  return {
    /**
     * Delete all Media matching the where query
     * @summary Delete multiple Media
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mediaDelete(
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaDelete200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.mediaDelete(
        where,
        sort,
        limit,
        page,
        depth,
        locale,
        fallbackLocale,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Find paginated Media
     * @summary Find paginated Media
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mediaGet(
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Medias>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.mediaGet(
        depth,
        locale,
        fallbackLocale,
        sort,
        where,
        limit,
        page,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Deletes an existing Media
     * @summary Deletes an existing Media
     * @param {string} id id of the Media
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mediaIdDelete(
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaUpsertConfirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.mediaIdDelete(
        id,
        depth,
        locale,
        fallbackLocale,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get a single Media by its id
     * @summary Get a single Media by its id
     * @param {string} id id of the Media
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mediaIdGet(
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Media>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.mediaIdGet(
        id,
        depth,
        locale,
        fallbackLocale,
        sort,
        where,
        limit,
        page,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Updates a Media
     * @summary Updates a Media
     * @param {string} id id of the Media
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Media} [media]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mediaIdPatch(
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      media?: Media,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaUpsertConfirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.mediaIdPatch(
        id,
        depth,
        locale,
        fallbackLocale,
        media,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update all Media matching the where query
     * @summary Update multiple Media
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Media} [media]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mediaPatch(
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      media?: Media,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaDelete200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.mediaPatch(
        where,
        sort,
        limit,
        page,
        depth,
        locale,
        fallbackLocale,
        media,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Create a new Media
     * @summary Create a new Media
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Media} [media]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mediaPost(
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      media?: Media,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaUpsertConfirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.mediaPost(depth, locale, fallbackLocale, media, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * MediaApi - factory interface
 * @export
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = MediaApiFp(configuration)
  return {
    /**
     * Delete all Media matching the where query
     * @summary Delete multiple Media
     * @param {MediaApiMediaDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mediaDelete(
      requestParameters: MediaApiMediaDeleteRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<MediaDelete200Response> {
      return localVarFp
        .mediaDelete(
          requestParameters.where,
          requestParameters.sort,
          requestParameters.limit,
          requestParameters.page,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Find paginated Media
     * @summary Find paginated Media
     * @param {MediaApiMediaGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mediaGet(requestParameters: MediaApiMediaGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Medias> {
      return localVarFp
        .mediaGet(
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.sort,
          requestParameters.where,
          requestParameters.limit,
          requestParameters.page,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Deletes an existing Media
     * @summary Deletes an existing Media
     * @param {MediaApiMediaIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mediaIdDelete(
      requestParameters: MediaApiMediaIdDeleteRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<MediaUpsertConfirmation> {
      return localVarFp
        .mediaIdDelete(
          requestParameters.id,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Get a single Media by its id
     * @summary Get a single Media by its id
     * @param {MediaApiMediaIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mediaIdGet(requestParameters: MediaApiMediaIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<Media> {
      return localVarFp
        .mediaIdGet(
          requestParameters.id,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.sort,
          requestParameters.where,
          requestParameters.limit,
          requestParameters.page,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Updates a Media
     * @summary Updates a Media
     * @param {MediaApiMediaIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mediaIdPatch(
      requestParameters: MediaApiMediaIdPatchRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<MediaUpsertConfirmation> {
      return localVarFp
        .mediaIdPatch(
          requestParameters.id,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.media,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update all Media matching the where query
     * @summary Update multiple Media
     * @param {MediaApiMediaPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mediaPatch(
      requestParameters: MediaApiMediaPatchRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<MediaDelete200Response> {
      return localVarFp
        .mediaPatch(
          requestParameters.where,
          requestParameters.sort,
          requestParameters.limit,
          requestParameters.page,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.media,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Create a new Media
     * @summary Create a new Media
     * @param {MediaApiMediaPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mediaPost(
      requestParameters: MediaApiMediaPostRequest = {},
      options?: AxiosRequestConfig
    ): AxiosPromise<MediaUpsertConfirmation> {
      return localVarFp
        .mediaPost(
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.media,
          options
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for mediaDelete operation in MediaApi.
 * @export
 * @interface MediaApiMediaDeleteRequest
 */
export interface MediaApiMediaDeleteRequest {
  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof MediaApiMediaDelete
   */
  readonly where: Where

  /**
   * sort by field
   * @type {string}
   * @memberof MediaApiMediaDelete
   */
  readonly sort?: string

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof MediaApiMediaDelete
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof MediaApiMediaDelete
   */
  readonly page?: number

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof MediaApiMediaDelete
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof MediaApiMediaDelete
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof MediaApiMediaDelete
   */
  readonly fallbackLocale?: string
}

/**
 * Request parameters for mediaGet operation in MediaApi.
 * @export
 * @interface MediaApiMediaGetRequest
 */
export interface MediaApiMediaGetRequest {
  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof MediaApiMediaGet
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof MediaApiMediaGet
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof MediaApiMediaGet
   */
  readonly fallbackLocale?: string

  /**
   * sort by field
   * @type {string}
   * @memberof MediaApiMediaGet
   */
  readonly sort?: string

  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof MediaApiMediaGet
   */
  readonly where?: Where

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof MediaApiMediaGet
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof MediaApiMediaGet
   */
  readonly page?: number
}

/**
 * Request parameters for mediaIdDelete operation in MediaApi.
 * @export
 * @interface MediaApiMediaIdDeleteRequest
 */
export interface MediaApiMediaIdDeleteRequest {
  /**
   * id of the Media
   * @type {string}
   * @memberof MediaApiMediaIdDelete
   */
  readonly id: string

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof MediaApiMediaIdDelete
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof MediaApiMediaIdDelete
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof MediaApiMediaIdDelete
   */
  readonly fallbackLocale?: string
}

/**
 * Request parameters for mediaIdGet operation in MediaApi.
 * @export
 * @interface MediaApiMediaIdGetRequest
 */
export interface MediaApiMediaIdGetRequest {
  /**
   * id of the Media
   * @type {string}
   * @memberof MediaApiMediaIdGet
   */
  readonly id: string

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof MediaApiMediaIdGet
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof MediaApiMediaIdGet
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof MediaApiMediaIdGet
   */
  readonly fallbackLocale?: string

  /**
   * sort by field
   * @type {string}
   * @memberof MediaApiMediaIdGet
   */
  readonly sort?: string

  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof MediaApiMediaIdGet
   */
  readonly where?: Where

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof MediaApiMediaIdGet
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof MediaApiMediaIdGet
   */
  readonly page?: number
}

/**
 * Request parameters for mediaIdPatch operation in MediaApi.
 * @export
 * @interface MediaApiMediaIdPatchRequest
 */
export interface MediaApiMediaIdPatchRequest {
  /**
   * id of the Media
   * @type {string}
   * @memberof MediaApiMediaIdPatch
   */
  readonly id: string

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof MediaApiMediaIdPatch
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof MediaApiMediaIdPatch
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof MediaApiMediaIdPatch
   */
  readonly fallbackLocale?: string

  /**
   *
   * @type {Media}
   * @memberof MediaApiMediaIdPatch
   */
  readonly media?: Media
}

/**
 * Request parameters for mediaPatch operation in MediaApi.
 * @export
 * @interface MediaApiMediaPatchRequest
 */
export interface MediaApiMediaPatchRequest {
  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof MediaApiMediaPatch
   */
  readonly where: Where

  /**
   * sort by field
   * @type {string}
   * @memberof MediaApiMediaPatch
   */
  readonly sort?: string

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof MediaApiMediaPatch
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof MediaApiMediaPatch
   */
  readonly page?: number

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof MediaApiMediaPatch
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof MediaApiMediaPatch
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof MediaApiMediaPatch
   */
  readonly fallbackLocale?: string

  /**
   *
   * @type {Media}
   * @memberof MediaApiMediaPatch
   */
  readonly media?: Media
}

/**
 * Request parameters for mediaPost operation in MediaApi.
 * @export
 * @interface MediaApiMediaPostRequest
 */
export interface MediaApiMediaPostRequest {
  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof MediaApiMediaPost
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof MediaApiMediaPost
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof MediaApiMediaPost
   */
  readonly fallbackLocale?: string

  /**
   *
   * @type {Media}
   * @memberof MediaApiMediaPost
   */
  readonly media?: Media
}

/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
export class MediaApi extends BaseAPI {
  /**
   * Delete all Media matching the where query
   * @summary Delete multiple Media
   * @param {MediaApiMediaDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MediaApi
   */
  public mediaDelete(requestParameters: MediaApiMediaDeleteRequest, options?: AxiosRequestConfig) {
    return MediaApiFp(this.configuration)
      .mediaDelete(
        requestParameters.where,
        requestParameters.sort,
        requestParameters.limit,
        requestParameters.page,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Find paginated Media
   * @summary Find paginated Media
   * @param {MediaApiMediaGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MediaApi
   */
  public mediaGet(requestParameters: MediaApiMediaGetRequest = {}, options?: AxiosRequestConfig) {
    return MediaApiFp(this.configuration)
      .mediaGet(
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.sort,
        requestParameters.where,
        requestParameters.limit,
        requestParameters.page,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Deletes an existing Media
   * @summary Deletes an existing Media
   * @param {MediaApiMediaIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MediaApi
   */
  public mediaIdDelete(requestParameters: MediaApiMediaIdDeleteRequest, options?: AxiosRequestConfig) {
    return MediaApiFp(this.configuration)
      .mediaIdDelete(
        requestParameters.id,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get a single Media by its id
   * @summary Get a single Media by its id
   * @param {MediaApiMediaIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MediaApi
   */
  public mediaIdGet(requestParameters: MediaApiMediaIdGetRequest, options?: AxiosRequestConfig) {
    return MediaApiFp(this.configuration)
      .mediaIdGet(
        requestParameters.id,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.sort,
        requestParameters.where,
        requestParameters.limit,
        requestParameters.page,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates a Media
   * @summary Updates a Media
   * @param {MediaApiMediaIdPatchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MediaApi
   */
  public mediaIdPatch(requestParameters: MediaApiMediaIdPatchRequest, options?: AxiosRequestConfig) {
    return MediaApiFp(this.configuration)
      .mediaIdPatch(
        requestParameters.id,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.media,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update all Media matching the where query
   * @summary Update multiple Media
   * @param {MediaApiMediaPatchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MediaApi
   */
  public mediaPatch(requestParameters: MediaApiMediaPatchRequest, options?: AxiosRequestConfig) {
    return MediaApiFp(this.configuration)
      .mediaPatch(
        requestParameters.where,
        requestParameters.sort,
        requestParameters.limit,
        requestParameters.page,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.media,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create a new Media
   * @summary Create a new Media
   * @param {MediaApiMediaPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MediaApi
   */
  public mediaPost(requestParameters: MediaApiMediaPostRequest = {}, options?: AxiosRequestConfig) {
    return MediaApiFp(this.configuration)
      .mediaPost(
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.media,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PostsApi - axios parameter creator
 * @export
 */
export const PostsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Delete all Posts matching the where query
     * @summary Delete multiple Posts
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsDelete: async (
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'where' is not null or undefined
      assertParamExists("postsDelete", "where", where)
      const localVarPath = `/posts`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Find paginated Posts
     * @summary Find paginated Posts
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsGet: async (
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/posts`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deletes an existing Post
     * @summary Deletes an existing Post
     * @param {string} id id of the Post
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdDelete: async (
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("postsIdDelete", "id", id)
      const localVarPath = `/posts/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get a single Post by its id
     * @summary Get a single Post by its id
     * @param {string} id id of the Post
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdGet: async (
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("postsIdGet", "id", id)
      const localVarPath = `/posts/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates a Post
     * @summary Updates a Post
     * @param {string} id id of the Post
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Posts} [posts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdPatch: async (
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      posts?: Posts,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("postsIdPatch", "id", id)
      const localVarPath = `/posts/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(posts, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update all Posts matching the where query
     * @summary Update multiple Posts
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Posts} [posts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsPatch: async (
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      posts?: Posts,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'where' is not null or undefined
      assertParamExists("postsPatch", "where", where)
      const localVarPath = `/posts`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(posts, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create a new Post
     * @summary Create a new Post
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Posts} [posts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsPost: async (
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      posts?: Posts,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/posts`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(posts, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PostsApi - functional programming interface
 * @export
 */
export const PostsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PostsApiAxiosParamCreator(configuration)
  return {
    /**
     * Delete all Posts matching the where query
     * @summary Delete multiple Posts
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postsDelete(
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostsDelete200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postsDelete(
        where,
        sort,
        limit,
        page,
        depth,
        locale,
        fallbackLocale,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Find paginated Posts
     * @summary Find paginated Posts
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postsGet(
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Postss>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postsGet(
        depth,
        locale,
        fallbackLocale,
        sort,
        where,
        limit,
        page,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Deletes an existing Post
     * @summary Deletes an existing Post
     * @param {string} id id of the Post
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postsIdDelete(
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostsUpsertConfirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postsIdDelete(
        id,
        depth,
        locale,
        fallbackLocale,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get a single Post by its id
     * @summary Get a single Post by its id
     * @param {string} id id of the Post
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postsIdGet(
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Posts>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postsIdGet(
        id,
        depth,
        locale,
        fallbackLocale,
        sort,
        where,
        limit,
        page,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Updates a Post
     * @summary Updates a Post
     * @param {string} id id of the Post
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Posts} [posts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postsIdPatch(
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      posts?: Posts,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostsUpsertConfirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postsIdPatch(
        id,
        depth,
        locale,
        fallbackLocale,
        posts,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update all Posts matching the where query
     * @summary Update multiple Posts
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Posts} [posts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postsPatch(
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      posts?: Posts,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostsDelete200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postsPatch(
        where,
        sort,
        limit,
        page,
        depth,
        locale,
        fallbackLocale,
        posts,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Create a new Post
     * @summary Create a new Post
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Posts} [posts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postsPost(
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      posts?: Posts,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostsUpsertConfirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postsPost(depth, locale, fallbackLocale, posts, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * PostsApi - factory interface
 * @export
 */
export const PostsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = PostsApiFp(configuration)
  return {
    /**
     * Delete all Posts matching the where query
     * @summary Delete multiple Posts
     * @param {PostsApiPostsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsDelete(
      requestParameters: PostsApiPostsDeleteRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<PostsDelete200Response> {
      return localVarFp
        .postsDelete(
          requestParameters.where,
          requestParameters.sort,
          requestParameters.limit,
          requestParameters.page,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Find paginated Posts
     * @summary Find paginated Posts
     * @param {PostsApiPostsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsGet(requestParameters: PostsApiPostsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Postss> {
      return localVarFp
        .postsGet(
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.sort,
          requestParameters.where,
          requestParameters.limit,
          requestParameters.page,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Deletes an existing Post
     * @summary Deletes an existing Post
     * @param {PostsApiPostsIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdDelete(
      requestParameters: PostsApiPostsIdDeleteRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<PostsUpsertConfirmation> {
      return localVarFp
        .postsIdDelete(
          requestParameters.id,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Get a single Post by its id
     * @summary Get a single Post by its id
     * @param {PostsApiPostsIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdGet(requestParameters: PostsApiPostsIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<Posts> {
      return localVarFp
        .postsIdGet(
          requestParameters.id,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.sort,
          requestParameters.where,
          requestParameters.limit,
          requestParameters.page,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Updates a Post
     * @summary Updates a Post
     * @param {PostsApiPostsIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsIdPatch(
      requestParameters: PostsApiPostsIdPatchRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<PostsUpsertConfirmation> {
      return localVarFp
        .postsIdPatch(
          requestParameters.id,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.posts,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update all Posts matching the where query
     * @summary Update multiple Posts
     * @param {PostsApiPostsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsPatch(
      requestParameters: PostsApiPostsPatchRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<PostsDelete200Response> {
      return localVarFp
        .postsPatch(
          requestParameters.where,
          requestParameters.sort,
          requestParameters.limit,
          requestParameters.page,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.posts,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Create a new Post
     * @summary Create a new Post
     * @param {PostsApiPostsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postsPost(
      requestParameters: PostsApiPostsPostRequest = {},
      options?: AxiosRequestConfig
    ): AxiosPromise<PostsUpsertConfirmation> {
      return localVarFp
        .postsPost(
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.posts,
          options
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for postsDelete operation in PostsApi.
 * @export
 * @interface PostsApiPostsDeleteRequest
 */
export interface PostsApiPostsDeleteRequest {
  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof PostsApiPostsDelete
   */
  readonly where: Where

  /**
   * sort by field
   * @type {string}
   * @memberof PostsApiPostsDelete
   */
  readonly sort?: string

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof PostsApiPostsDelete
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof PostsApiPostsDelete
   */
  readonly page?: number

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof PostsApiPostsDelete
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof PostsApiPostsDelete
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof PostsApiPostsDelete
   */
  readonly fallbackLocale?: string
}

/**
 * Request parameters for postsGet operation in PostsApi.
 * @export
 * @interface PostsApiPostsGetRequest
 */
export interface PostsApiPostsGetRequest {
  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof PostsApiPostsGet
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof PostsApiPostsGet
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof PostsApiPostsGet
   */
  readonly fallbackLocale?: string

  /**
   * sort by field
   * @type {string}
   * @memberof PostsApiPostsGet
   */
  readonly sort?: string

  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof PostsApiPostsGet
   */
  readonly where?: Where

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof PostsApiPostsGet
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof PostsApiPostsGet
   */
  readonly page?: number
}

/**
 * Request parameters for postsIdDelete operation in PostsApi.
 * @export
 * @interface PostsApiPostsIdDeleteRequest
 */
export interface PostsApiPostsIdDeleteRequest {
  /**
   * id of the Post
   * @type {string}
   * @memberof PostsApiPostsIdDelete
   */
  readonly id: string

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof PostsApiPostsIdDelete
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof PostsApiPostsIdDelete
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof PostsApiPostsIdDelete
   */
  readonly fallbackLocale?: string
}

/**
 * Request parameters for postsIdGet operation in PostsApi.
 * @export
 * @interface PostsApiPostsIdGetRequest
 */
export interface PostsApiPostsIdGetRequest {
  /**
   * id of the Post
   * @type {string}
   * @memberof PostsApiPostsIdGet
   */
  readonly id: string

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof PostsApiPostsIdGet
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof PostsApiPostsIdGet
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof PostsApiPostsIdGet
   */
  readonly fallbackLocale?: string

  /**
   * sort by field
   * @type {string}
   * @memberof PostsApiPostsIdGet
   */
  readonly sort?: string

  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof PostsApiPostsIdGet
   */
  readonly where?: Where

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof PostsApiPostsIdGet
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof PostsApiPostsIdGet
   */
  readonly page?: number
}

/**
 * Request parameters for postsIdPatch operation in PostsApi.
 * @export
 * @interface PostsApiPostsIdPatchRequest
 */
export interface PostsApiPostsIdPatchRequest {
  /**
   * id of the Post
   * @type {string}
   * @memberof PostsApiPostsIdPatch
   */
  readonly id: string

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof PostsApiPostsIdPatch
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof PostsApiPostsIdPatch
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof PostsApiPostsIdPatch
   */
  readonly fallbackLocale?: string

  /**
   *
   * @type {Posts}
   * @memberof PostsApiPostsIdPatch
   */
  readonly posts?: Posts
}

/**
 * Request parameters for postsPatch operation in PostsApi.
 * @export
 * @interface PostsApiPostsPatchRequest
 */
export interface PostsApiPostsPatchRequest {
  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof PostsApiPostsPatch
   */
  readonly where: Where

  /**
   * sort by field
   * @type {string}
   * @memberof PostsApiPostsPatch
   */
  readonly sort?: string

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof PostsApiPostsPatch
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof PostsApiPostsPatch
   */
  readonly page?: number

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof PostsApiPostsPatch
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof PostsApiPostsPatch
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof PostsApiPostsPatch
   */
  readonly fallbackLocale?: string

  /**
   *
   * @type {Posts}
   * @memberof PostsApiPostsPatch
   */
  readonly posts?: Posts
}

/**
 * Request parameters for postsPost operation in PostsApi.
 * @export
 * @interface PostsApiPostsPostRequest
 */
export interface PostsApiPostsPostRequest {
  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof PostsApiPostsPost
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof PostsApiPostsPost
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof PostsApiPostsPost
   */
  readonly fallbackLocale?: string

  /**
   *
   * @type {Posts}
   * @memberof PostsApiPostsPost
   */
  readonly posts?: Posts
}

/**
 * PostsApi - object-oriented interface
 * @export
 * @class PostsApi
 * @extends {BaseAPI}
 */
export class PostsApi extends BaseAPI {
  /**
   * Delete all Posts matching the where query
   * @summary Delete multiple Posts
   * @param {PostsApiPostsDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostsApi
   */
  public postsDelete(requestParameters: PostsApiPostsDeleteRequest, options?: AxiosRequestConfig) {
    return PostsApiFp(this.configuration)
      .postsDelete(
        requestParameters.where,
        requestParameters.sort,
        requestParameters.limit,
        requestParameters.page,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Find paginated Posts
   * @summary Find paginated Posts
   * @param {PostsApiPostsGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostsApi
   */
  public postsGet(requestParameters: PostsApiPostsGetRequest = {}, options?: AxiosRequestConfig) {
    return PostsApiFp(this.configuration)
      .postsGet(
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.sort,
        requestParameters.where,
        requestParameters.limit,
        requestParameters.page,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Deletes an existing Post
   * @summary Deletes an existing Post
   * @param {PostsApiPostsIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostsApi
   */
  public postsIdDelete(requestParameters: PostsApiPostsIdDeleteRequest, options?: AxiosRequestConfig) {
    return PostsApiFp(this.configuration)
      .postsIdDelete(
        requestParameters.id,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get a single Post by its id
   * @summary Get a single Post by its id
   * @param {PostsApiPostsIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostsApi
   */
  public postsIdGet(requestParameters: PostsApiPostsIdGetRequest, options?: AxiosRequestConfig) {
    return PostsApiFp(this.configuration)
      .postsIdGet(
        requestParameters.id,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.sort,
        requestParameters.where,
        requestParameters.limit,
        requestParameters.page,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates a Post
   * @summary Updates a Post
   * @param {PostsApiPostsIdPatchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostsApi
   */
  public postsIdPatch(requestParameters: PostsApiPostsIdPatchRequest, options?: AxiosRequestConfig) {
    return PostsApiFp(this.configuration)
      .postsIdPatch(
        requestParameters.id,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.posts,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update all Posts matching the where query
   * @summary Update multiple Posts
   * @param {PostsApiPostsPatchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostsApi
   */
  public postsPatch(requestParameters: PostsApiPostsPatchRequest, options?: AxiosRequestConfig) {
    return PostsApiFp(this.configuration)
      .postsPatch(
        requestParameters.where,
        requestParameters.sort,
        requestParameters.limit,
        requestParameters.page,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.posts,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create a new Post
   * @summary Create a new Post
   * @param {PostsApiPostsPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostsApi
   */
  public postsPost(requestParameters: PostsApiPostsPostRequest = {}, options?: AxiosRequestConfig) {
    return PostsApiFp(this.configuration)
      .postsPost(
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.posts,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ProfilesApi - axios parameter creator
 * @export
 */
export const ProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Delete all Profiles matching the where query
     * @summary Delete multiple Profiles
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesDelete: async (
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'where' is not null or undefined
      assertParamExists("profilesDelete", "where", where)
      const localVarPath = `/profiles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Find paginated Profiles
     * @summary Find paginated Profiles
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesGet: async (
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/profiles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deletes an existing Profile
     * @summary Deletes an existing Profile
     * @param {string} id id of the Profile
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesIdDelete: async (
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("profilesIdDelete", "id", id)
      const localVarPath = `/profiles/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get a single Profile by its id
     * @summary Get a single Profile by its id
     * @param {string} id id of the Profile
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesIdGet: async (
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("profilesIdGet", "id", id)
      const localVarPath = `/profiles/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates a Profile
     * @summary Updates a Profile
     * @param {string} id id of the Profile
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Profiles} [profiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesIdPatch: async (
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      profiles?: Profiles,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("profilesIdPatch", "id", id)
      const localVarPath = `/profiles/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(profiles, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update all Profiles matching the where query
     * @summary Update multiple Profiles
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Profiles} [profiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesPatch: async (
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      profiles?: Profiles,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'where' is not null or undefined
      assertParamExists("profilesPatch", "where", where)
      const localVarPath = `/profiles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(profiles, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create a new Profile
     * @summary Create a new Profile
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Profiles} [profiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesPost: async (
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      profiles?: Profiles,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/profiles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(profiles, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ProfilesApi - functional programming interface
 * @export
 */
export const ProfilesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProfilesApiAxiosParamCreator(configuration)
  return {
    /**
     * Delete all Profiles matching the where query
     * @summary Delete multiple Profiles
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async profilesDelete(
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfilesDelete200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.profilesDelete(
        where,
        sort,
        limit,
        page,
        depth,
        locale,
        fallbackLocale,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Find paginated Profiles
     * @summary Find paginated Profiles
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async profilesGet(
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profiless>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.profilesGet(
        depth,
        locale,
        fallbackLocale,
        sort,
        where,
        limit,
        page,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Deletes an existing Profile
     * @summary Deletes an existing Profile
     * @param {string} id id of the Profile
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async profilesIdDelete(
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfilesUpsertConfirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.profilesIdDelete(
        id,
        depth,
        locale,
        fallbackLocale,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get a single Profile by its id
     * @summary Get a single Profile by its id
     * @param {string} id id of the Profile
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async profilesIdGet(
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profiles>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.profilesIdGet(
        id,
        depth,
        locale,
        fallbackLocale,
        sort,
        where,
        limit,
        page,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Updates a Profile
     * @summary Updates a Profile
     * @param {string} id id of the Profile
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Profiles} [profiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async profilesIdPatch(
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      profiles?: Profiles,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfilesUpsertConfirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.profilesIdPatch(
        id,
        depth,
        locale,
        fallbackLocale,
        profiles,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update all Profiles matching the where query
     * @summary Update multiple Profiles
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Profiles} [profiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async profilesPatch(
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      profiles?: Profiles,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfilesDelete200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.profilesPatch(
        where,
        sort,
        limit,
        page,
        depth,
        locale,
        fallbackLocale,
        profiles,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Create a new Profile
     * @summary Create a new Profile
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Profiles} [profiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async profilesPost(
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      profiles?: Profiles,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfilesUpsertConfirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.profilesPost(
        depth,
        locale,
        fallbackLocale,
        profiles,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ProfilesApi - factory interface
 * @export
 */
export const ProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ProfilesApiFp(configuration)
  return {
    /**
     * Delete all Profiles matching the where query
     * @summary Delete multiple Profiles
     * @param {ProfilesApiProfilesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesDelete(
      requestParameters: ProfilesApiProfilesDeleteRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<ProfilesDelete200Response> {
      return localVarFp
        .profilesDelete(
          requestParameters.where,
          requestParameters.sort,
          requestParameters.limit,
          requestParameters.page,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Find paginated Profiles
     * @summary Find paginated Profiles
     * @param {ProfilesApiProfilesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesGet(
      requestParameters: ProfilesApiProfilesGetRequest = {},
      options?: AxiosRequestConfig
    ): AxiosPromise<Profiless> {
      return localVarFp
        .profilesGet(
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.sort,
          requestParameters.where,
          requestParameters.limit,
          requestParameters.page,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Deletes an existing Profile
     * @summary Deletes an existing Profile
     * @param {ProfilesApiProfilesIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesIdDelete(
      requestParameters: ProfilesApiProfilesIdDeleteRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<ProfilesUpsertConfirmation> {
      return localVarFp
        .profilesIdDelete(
          requestParameters.id,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Get a single Profile by its id
     * @summary Get a single Profile by its id
     * @param {ProfilesApiProfilesIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesIdGet(
      requestParameters: ProfilesApiProfilesIdGetRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<Profiles> {
      return localVarFp
        .profilesIdGet(
          requestParameters.id,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.sort,
          requestParameters.where,
          requestParameters.limit,
          requestParameters.page,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Updates a Profile
     * @summary Updates a Profile
     * @param {ProfilesApiProfilesIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesIdPatch(
      requestParameters: ProfilesApiProfilesIdPatchRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<ProfilesUpsertConfirmation> {
      return localVarFp
        .profilesIdPatch(
          requestParameters.id,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.profiles,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update all Profiles matching the where query
     * @summary Update multiple Profiles
     * @param {ProfilesApiProfilesPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesPatch(
      requestParameters: ProfilesApiProfilesPatchRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<ProfilesDelete200Response> {
      return localVarFp
        .profilesPatch(
          requestParameters.where,
          requestParameters.sort,
          requestParameters.limit,
          requestParameters.page,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.profiles,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Create a new Profile
     * @summary Create a new Profile
     * @param {ProfilesApiProfilesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profilesPost(
      requestParameters: ProfilesApiProfilesPostRequest = {},
      options?: AxiosRequestConfig
    ): AxiosPromise<ProfilesUpsertConfirmation> {
      return localVarFp
        .profilesPost(
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.profiles,
          options
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for profilesDelete operation in ProfilesApi.
 * @export
 * @interface ProfilesApiProfilesDeleteRequest
 */
export interface ProfilesApiProfilesDeleteRequest {
  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof ProfilesApiProfilesDelete
   */
  readonly where: Where

  /**
   * sort by field
   * @type {string}
   * @memberof ProfilesApiProfilesDelete
   */
  readonly sort?: string

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof ProfilesApiProfilesDelete
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof ProfilesApiProfilesDelete
   */
  readonly page?: number

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof ProfilesApiProfilesDelete
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof ProfilesApiProfilesDelete
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof ProfilesApiProfilesDelete
   */
  readonly fallbackLocale?: string
}

/**
 * Request parameters for profilesGet operation in ProfilesApi.
 * @export
 * @interface ProfilesApiProfilesGetRequest
 */
export interface ProfilesApiProfilesGetRequest {
  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof ProfilesApiProfilesGet
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof ProfilesApiProfilesGet
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof ProfilesApiProfilesGet
   */
  readonly fallbackLocale?: string

  /**
   * sort by field
   * @type {string}
   * @memberof ProfilesApiProfilesGet
   */
  readonly sort?: string

  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof ProfilesApiProfilesGet
   */
  readonly where?: Where

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof ProfilesApiProfilesGet
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof ProfilesApiProfilesGet
   */
  readonly page?: number
}

/**
 * Request parameters for profilesIdDelete operation in ProfilesApi.
 * @export
 * @interface ProfilesApiProfilesIdDeleteRequest
 */
export interface ProfilesApiProfilesIdDeleteRequest {
  /**
   * id of the Profile
   * @type {string}
   * @memberof ProfilesApiProfilesIdDelete
   */
  readonly id: string

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof ProfilesApiProfilesIdDelete
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof ProfilesApiProfilesIdDelete
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof ProfilesApiProfilesIdDelete
   */
  readonly fallbackLocale?: string
}

/**
 * Request parameters for profilesIdGet operation in ProfilesApi.
 * @export
 * @interface ProfilesApiProfilesIdGetRequest
 */
export interface ProfilesApiProfilesIdGetRequest {
  /**
   * id of the Profile
   * @type {string}
   * @memberof ProfilesApiProfilesIdGet
   */
  readonly id: string

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof ProfilesApiProfilesIdGet
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof ProfilesApiProfilesIdGet
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof ProfilesApiProfilesIdGet
   */
  readonly fallbackLocale?: string

  /**
   * sort by field
   * @type {string}
   * @memberof ProfilesApiProfilesIdGet
   */
  readonly sort?: string

  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof ProfilesApiProfilesIdGet
   */
  readonly where?: Where

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof ProfilesApiProfilesIdGet
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof ProfilesApiProfilesIdGet
   */
  readonly page?: number
}

/**
 * Request parameters for profilesIdPatch operation in ProfilesApi.
 * @export
 * @interface ProfilesApiProfilesIdPatchRequest
 */
export interface ProfilesApiProfilesIdPatchRequest {
  /**
   * id of the Profile
   * @type {string}
   * @memberof ProfilesApiProfilesIdPatch
   */
  readonly id: string

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof ProfilesApiProfilesIdPatch
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof ProfilesApiProfilesIdPatch
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof ProfilesApiProfilesIdPatch
   */
  readonly fallbackLocale?: string

  /**
   *
   * @type {Profiles}
   * @memberof ProfilesApiProfilesIdPatch
   */
  readonly profiles?: Profiles
}

/**
 * Request parameters for profilesPatch operation in ProfilesApi.
 * @export
 * @interface ProfilesApiProfilesPatchRequest
 */
export interface ProfilesApiProfilesPatchRequest {
  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof ProfilesApiProfilesPatch
   */
  readonly where: Where

  /**
   * sort by field
   * @type {string}
   * @memberof ProfilesApiProfilesPatch
   */
  readonly sort?: string

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof ProfilesApiProfilesPatch
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof ProfilesApiProfilesPatch
   */
  readonly page?: number

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof ProfilesApiProfilesPatch
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof ProfilesApiProfilesPatch
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof ProfilesApiProfilesPatch
   */
  readonly fallbackLocale?: string

  /**
   *
   * @type {Profiles}
   * @memberof ProfilesApiProfilesPatch
   */
  readonly profiles?: Profiles
}

/**
 * Request parameters for profilesPost operation in ProfilesApi.
 * @export
 * @interface ProfilesApiProfilesPostRequest
 */
export interface ProfilesApiProfilesPostRequest {
  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof ProfilesApiProfilesPost
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof ProfilesApiProfilesPost
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof ProfilesApiProfilesPost
   */
  readonly fallbackLocale?: string

  /**
   *
   * @type {Profiles}
   * @memberof ProfilesApiProfilesPost
   */
  readonly profiles?: Profiles
}

/**
 * ProfilesApi - object-oriented interface
 * @export
 * @class ProfilesApi
 * @extends {BaseAPI}
 */
export class ProfilesApi extends BaseAPI {
  /**
   * Delete all Profiles matching the where query
   * @summary Delete multiple Profiles
   * @param {ProfilesApiProfilesDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilesApi
   */
  public profilesDelete(requestParameters: ProfilesApiProfilesDeleteRequest, options?: AxiosRequestConfig) {
    return ProfilesApiFp(this.configuration)
      .profilesDelete(
        requestParameters.where,
        requestParameters.sort,
        requestParameters.limit,
        requestParameters.page,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Find paginated Profiles
   * @summary Find paginated Profiles
   * @param {ProfilesApiProfilesGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilesApi
   */
  public profilesGet(requestParameters: ProfilesApiProfilesGetRequest = {}, options?: AxiosRequestConfig) {
    return ProfilesApiFp(this.configuration)
      .profilesGet(
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.sort,
        requestParameters.where,
        requestParameters.limit,
        requestParameters.page,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Deletes an existing Profile
   * @summary Deletes an existing Profile
   * @param {ProfilesApiProfilesIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilesApi
   */
  public profilesIdDelete(requestParameters: ProfilesApiProfilesIdDeleteRequest, options?: AxiosRequestConfig) {
    return ProfilesApiFp(this.configuration)
      .profilesIdDelete(
        requestParameters.id,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get a single Profile by its id
   * @summary Get a single Profile by its id
   * @param {ProfilesApiProfilesIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilesApi
   */
  public profilesIdGet(requestParameters: ProfilesApiProfilesIdGetRequest, options?: AxiosRequestConfig) {
    return ProfilesApiFp(this.configuration)
      .profilesIdGet(
        requestParameters.id,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.sort,
        requestParameters.where,
        requestParameters.limit,
        requestParameters.page,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates a Profile
   * @summary Updates a Profile
   * @param {ProfilesApiProfilesIdPatchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilesApi
   */
  public profilesIdPatch(requestParameters: ProfilesApiProfilesIdPatchRequest, options?: AxiosRequestConfig) {
    return ProfilesApiFp(this.configuration)
      .profilesIdPatch(
        requestParameters.id,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.profiles,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update all Profiles matching the where query
   * @summary Update multiple Profiles
   * @param {ProfilesApiProfilesPatchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilesApi
   */
  public profilesPatch(requestParameters: ProfilesApiProfilesPatchRequest, options?: AxiosRequestConfig) {
    return ProfilesApiFp(this.configuration)
      .profilesPatch(
        requestParameters.where,
        requestParameters.sort,
        requestParameters.limit,
        requestParameters.page,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.profiles,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create a new Profile
   * @summary Create a new Profile
   * @param {ProfilesApiProfilesPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfilesApi
   */
  public profilesPost(requestParameters: ProfilesApiProfilesPostRequest = {}, options?: AxiosRequestConfig) {
    return ProfilesApiFp(this.configuration)
      .profilesPost(
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.profiles,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SkillsApi - axios parameter creator
 * @export
 */
export const SkillsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Delete all Skills matching the where query
     * @summary Delete multiple Skills
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    skillsDelete: async (
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'where' is not null or undefined
      assertParamExists("skillsDelete", "where", where)
      const localVarPath = `/skills`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Find paginated Skills
     * @summary Find paginated Skills
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    skillsGet: async (
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/skills`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deletes an existing Skill
     * @summary Deletes an existing Skill
     * @param {string} id id of the Skill
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    skillsIdDelete: async (
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("skillsIdDelete", "id", id)
      const localVarPath = `/skills/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get a single Skill by its id
     * @summary Get a single Skill by its id
     * @param {string} id id of the Skill
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    skillsIdGet: async (
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("skillsIdGet", "id", id)
      const localVarPath = `/skills/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates a Skill
     * @summary Updates a Skill
     * @param {string} id id of the Skill
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Skills} [skills]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    skillsIdPatch: async (
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      skills?: Skills,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("skillsIdPatch", "id", id)
      const localVarPath = `/skills/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(skills, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update all Skills matching the where query
     * @summary Update multiple Skills
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Skills} [skills]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    skillsPatch: async (
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      skills?: Skills,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'where' is not null or undefined
      assertParamExists("skillsPatch", "where", where)
      const localVarPath = `/skills`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(skills, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create a new Skill
     * @summary Create a new Skill
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Skills} [skills]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    skillsPost: async (
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      skills?: Skills,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/skills`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(skills, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SkillsApi - functional programming interface
 * @export
 */
export const SkillsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SkillsApiAxiosParamCreator(configuration)
  return {
    /**
     * Delete all Skills matching the where query
     * @summary Delete multiple Skills
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async skillsDelete(
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SkillsDelete200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.skillsDelete(
        where,
        sort,
        limit,
        page,
        depth,
        locale,
        fallbackLocale,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Find paginated Skills
     * @summary Find paginated Skills
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async skillsGet(
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Skillss>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.skillsGet(
        depth,
        locale,
        fallbackLocale,
        sort,
        where,
        limit,
        page,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Deletes an existing Skill
     * @summary Deletes an existing Skill
     * @param {string} id id of the Skill
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async skillsIdDelete(
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SkillsUpsertConfirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.skillsIdDelete(
        id,
        depth,
        locale,
        fallbackLocale,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get a single Skill by its id
     * @summary Get a single Skill by its id
     * @param {string} id id of the Skill
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async skillsIdGet(
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Skills>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.skillsIdGet(
        id,
        depth,
        locale,
        fallbackLocale,
        sort,
        where,
        limit,
        page,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Updates a Skill
     * @summary Updates a Skill
     * @param {string} id id of the Skill
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Skills} [skills]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async skillsIdPatch(
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      skills?: Skills,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SkillsUpsertConfirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.skillsIdPatch(
        id,
        depth,
        locale,
        fallbackLocale,
        skills,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update all Skills matching the where query
     * @summary Update multiple Skills
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Skills} [skills]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async skillsPatch(
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      skills?: Skills,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SkillsDelete200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.skillsPatch(
        where,
        sort,
        limit,
        page,
        depth,
        locale,
        fallbackLocale,
        skills,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Create a new Skill
     * @summary Create a new Skill
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Skills} [skills]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async skillsPost(
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      skills?: Skills,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SkillsUpsertConfirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.skillsPost(
        depth,
        locale,
        fallbackLocale,
        skills,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * SkillsApi - factory interface
 * @export
 */
export const SkillsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SkillsApiFp(configuration)
  return {
    /**
     * Delete all Skills matching the where query
     * @summary Delete multiple Skills
     * @param {SkillsApiSkillsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    skillsDelete(
      requestParameters: SkillsApiSkillsDeleteRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<SkillsDelete200Response> {
      return localVarFp
        .skillsDelete(
          requestParameters.where,
          requestParameters.sort,
          requestParameters.limit,
          requestParameters.page,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Find paginated Skills
     * @summary Find paginated Skills
     * @param {SkillsApiSkillsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    skillsGet(requestParameters: SkillsApiSkillsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Skillss> {
      return localVarFp
        .skillsGet(
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.sort,
          requestParameters.where,
          requestParameters.limit,
          requestParameters.page,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Deletes an existing Skill
     * @summary Deletes an existing Skill
     * @param {SkillsApiSkillsIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    skillsIdDelete(
      requestParameters: SkillsApiSkillsIdDeleteRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<SkillsUpsertConfirmation> {
      return localVarFp
        .skillsIdDelete(
          requestParameters.id,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Get a single Skill by its id
     * @summary Get a single Skill by its id
     * @param {SkillsApiSkillsIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    skillsIdGet(requestParameters: SkillsApiSkillsIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<Skills> {
      return localVarFp
        .skillsIdGet(
          requestParameters.id,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.sort,
          requestParameters.where,
          requestParameters.limit,
          requestParameters.page,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Updates a Skill
     * @summary Updates a Skill
     * @param {SkillsApiSkillsIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    skillsIdPatch(
      requestParameters: SkillsApiSkillsIdPatchRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<SkillsUpsertConfirmation> {
      return localVarFp
        .skillsIdPatch(
          requestParameters.id,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.skills,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update all Skills matching the where query
     * @summary Update multiple Skills
     * @param {SkillsApiSkillsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    skillsPatch(
      requestParameters: SkillsApiSkillsPatchRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<SkillsDelete200Response> {
      return localVarFp
        .skillsPatch(
          requestParameters.where,
          requestParameters.sort,
          requestParameters.limit,
          requestParameters.page,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.skills,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Create a new Skill
     * @summary Create a new Skill
     * @param {SkillsApiSkillsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    skillsPost(
      requestParameters: SkillsApiSkillsPostRequest = {},
      options?: AxiosRequestConfig
    ): AxiosPromise<SkillsUpsertConfirmation> {
      return localVarFp
        .skillsPost(
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.skills,
          options
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for skillsDelete operation in SkillsApi.
 * @export
 * @interface SkillsApiSkillsDeleteRequest
 */
export interface SkillsApiSkillsDeleteRequest {
  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof SkillsApiSkillsDelete
   */
  readonly where: Where

  /**
   * sort by field
   * @type {string}
   * @memberof SkillsApiSkillsDelete
   */
  readonly sort?: string

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof SkillsApiSkillsDelete
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof SkillsApiSkillsDelete
   */
  readonly page?: number

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof SkillsApiSkillsDelete
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof SkillsApiSkillsDelete
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof SkillsApiSkillsDelete
   */
  readonly fallbackLocale?: string
}

/**
 * Request parameters for skillsGet operation in SkillsApi.
 * @export
 * @interface SkillsApiSkillsGetRequest
 */
export interface SkillsApiSkillsGetRequest {
  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof SkillsApiSkillsGet
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof SkillsApiSkillsGet
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof SkillsApiSkillsGet
   */
  readonly fallbackLocale?: string

  /**
   * sort by field
   * @type {string}
   * @memberof SkillsApiSkillsGet
   */
  readonly sort?: string

  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof SkillsApiSkillsGet
   */
  readonly where?: Where

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof SkillsApiSkillsGet
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof SkillsApiSkillsGet
   */
  readonly page?: number
}

/**
 * Request parameters for skillsIdDelete operation in SkillsApi.
 * @export
 * @interface SkillsApiSkillsIdDeleteRequest
 */
export interface SkillsApiSkillsIdDeleteRequest {
  /**
   * id of the Skill
   * @type {string}
   * @memberof SkillsApiSkillsIdDelete
   */
  readonly id: string

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof SkillsApiSkillsIdDelete
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof SkillsApiSkillsIdDelete
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof SkillsApiSkillsIdDelete
   */
  readonly fallbackLocale?: string
}

/**
 * Request parameters for skillsIdGet operation in SkillsApi.
 * @export
 * @interface SkillsApiSkillsIdGetRequest
 */
export interface SkillsApiSkillsIdGetRequest {
  /**
   * id of the Skill
   * @type {string}
   * @memberof SkillsApiSkillsIdGet
   */
  readonly id: string

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof SkillsApiSkillsIdGet
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof SkillsApiSkillsIdGet
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof SkillsApiSkillsIdGet
   */
  readonly fallbackLocale?: string

  /**
   * sort by field
   * @type {string}
   * @memberof SkillsApiSkillsIdGet
   */
  readonly sort?: string

  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof SkillsApiSkillsIdGet
   */
  readonly where?: Where

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof SkillsApiSkillsIdGet
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof SkillsApiSkillsIdGet
   */
  readonly page?: number
}

/**
 * Request parameters for skillsIdPatch operation in SkillsApi.
 * @export
 * @interface SkillsApiSkillsIdPatchRequest
 */
export interface SkillsApiSkillsIdPatchRequest {
  /**
   * id of the Skill
   * @type {string}
   * @memberof SkillsApiSkillsIdPatch
   */
  readonly id: string

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof SkillsApiSkillsIdPatch
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof SkillsApiSkillsIdPatch
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof SkillsApiSkillsIdPatch
   */
  readonly fallbackLocale?: string

  /**
   *
   * @type {Skills}
   * @memberof SkillsApiSkillsIdPatch
   */
  readonly skills?: Skills
}

/**
 * Request parameters for skillsPatch operation in SkillsApi.
 * @export
 * @interface SkillsApiSkillsPatchRequest
 */
export interface SkillsApiSkillsPatchRequest {
  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof SkillsApiSkillsPatch
   */
  readonly where: Where

  /**
   * sort by field
   * @type {string}
   * @memberof SkillsApiSkillsPatch
   */
  readonly sort?: string

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof SkillsApiSkillsPatch
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof SkillsApiSkillsPatch
   */
  readonly page?: number

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof SkillsApiSkillsPatch
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof SkillsApiSkillsPatch
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof SkillsApiSkillsPatch
   */
  readonly fallbackLocale?: string

  /**
   *
   * @type {Skills}
   * @memberof SkillsApiSkillsPatch
   */
  readonly skills?: Skills
}

/**
 * Request parameters for skillsPost operation in SkillsApi.
 * @export
 * @interface SkillsApiSkillsPostRequest
 */
export interface SkillsApiSkillsPostRequest {
  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof SkillsApiSkillsPost
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof SkillsApiSkillsPost
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof SkillsApiSkillsPost
   */
  readonly fallbackLocale?: string

  /**
   *
   * @type {Skills}
   * @memberof SkillsApiSkillsPost
   */
  readonly skills?: Skills
}

/**
 * SkillsApi - object-oriented interface
 * @export
 * @class SkillsApi
 * @extends {BaseAPI}
 */
export class SkillsApi extends BaseAPI {
  /**
   * Delete all Skills matching the where query
   * @summary Delete multiple Skills
   * @param {SkillsApiSkillsDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkillsApi
   */
  public skillsDelete(requestParameters: SkillsApiSkillsDeleteRequest, options?: AxiosRequestConfig) {
    return SkillsApiFp(this.configuration)
      .skillsDelete(
        requestParameters.where,
        requestParameters.sort,
        requestParameters.limit,
        requestParameters.page,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Find paginated Skills
   * @summary Find paginated Skills
   * @param {SkillsApiSkillsGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkillsApi
   */
  public skillsGet(requestParameters: SkillsApiSkillsGetRequest = {}, options?: AxiosRequestConfig) {
    return SkillsApiFp(this.configuration)
      .skillsGet(
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.sort,
        requestParameters.where,
        requestParameters.limit,
        requestParameters.page,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Deletes an existing Skill
   * @summary Deletes an existing Skill
   * @param {SkillsApiSkillsIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkillsApi
   */
  public skillsIdDelete(requestParameters: SkillsApiSkillsIdDeleteRequest, options?: AxiosRequestConfig) {
    return SkillsApiFp(this.configuration)
      .skillsIdDelete(
        requestParameters.id,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get a single Skill by its id
   * @summary Get a single Skill by its id
   * @param {SkillsApiSkillsIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkillsApi
   */
  public skillsIdGet(requestParameters: SkillsApiSkillsIdGetRequest, options?: AxiosRequestConfig) {
    return SkillsApiFp(this.configuration)
      .skillsIdGet(
        requestParameters.id,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.sort,
        requestParameters.where,
        requestParameters.limit,
        requestParameters.page,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates a Skill
   * @summary Updates a Skill
   * @param {SkillsApiSkillsIdPatchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkillsApi
   */
  public skillsIdPatch(requestParameters: SkillsApiSkillsIdPatchRequest, options?: AxiosRequestConfig) {
    return SkillsApiFp(this.configuration)
      .skillsIdPatch(
        requestParameters.id,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.skills,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update all Skills matching the where query
   * @summary Update multiple Skills
   * @param {SkillsApiSkillsPatchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkillsApi
   */
  public skillsPatch(requestParameters: SkillsApiSkillsPatchRequest, options?: AxiosRequestConfig) {
    return SkillsApiFp(this.configuration)
      .skillsPatch(
        requestParameters.where,
        requestParameters.sort,
        requestParameters.limit,
        requestParameters.page,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.skills,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create a new Skill
   * @summary Create a new Skill
   * @param {SkillsApiSkillsPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkillsApi
   */
  public skillsPost(requestParameters: SkillsApiSkillsPostRequest = {}, options?: AxiosRequestConfig) {
    return SkillsApiFp(this.configuration)
      .skillsPost(
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.skills,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Delete all Users matching the where query
     * @summary Delete multiple Users
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersDelete: async (
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'where' is not null or undefined
      assertParamExists("usersDelete", "where", where)
      const localVarPath = `/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Find paginated Users
     * @summary Find paginated Users
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersGet: async (
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deletes an existing User
     * @summary Deletes an existing User
     * @param {string} id id of the User
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdDelete: async (
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("usersIdDelete", "id", id)
      const localVarPath = `/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get a single User by its id
     * @summary Get a single User by its id
     * @param {string} id id of the User
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdGet: async (
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("usersIdGet", "id", id)
      const localVarPath = `/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates a User
     * @summary Updates a User
     * @param {string} id id of the User
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Users} [users]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdPatch: async (
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      users?: Users,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("usersIdPatch", "id", id)
      const localVarPath = `/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(users, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update all Users matching the where query
     * @summary Update multiple Users
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Users} [users]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPatch: async (
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      users?: Users,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'where' is not null or undefined
      assertParamExists("usersPatch", "where", where)
      const localVarPath = `/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (where !== undefined) {
        localVarQueryParameter["where"] = where
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page
      }

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(users, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create a new User
     * @summary Create a new User
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Users} [users]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPost: async (
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      users?: Users,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basicAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication cookieAuth required

      if (depth !== undefined) {
        localVarQueryParameter["depth"] = depth
      }

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale
      }

      if (fallbackLocale !== undefined) {
        localVarQueryParameter["fallback-locale"] = fallbackLocale
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(users, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
  return {
    /**
     * Delete all Users matching the where query
     * @summary Delete multiple Users
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersDelete(
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersDelete200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersDelete(
        where,
        sort,
        limit,
        page,
        depth,
        locale,
        fallbackLocale,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Find paginated Users
     * @summary Find paginated Users
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersGet(
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Userss>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(
        depth,
        locale,
        fallbackLocale,
        sort,
        where,
        limit,
        page,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Deletes an existing User
     * @summary Deletes an existing User
     * @param {string} id id of the User
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdDelete(
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersUpsertConfirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdDelete(
        id,
        depth,
        locale,
        fallbackLocale,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get a single User by its id
     * @summary Get a single User by its id
     * @param {string} id id of the User
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {string} [sort] sort by field
     * @param {Where} [where] pass a where query to constrain returned documents (complex type, see documentation)
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdGet(
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      sort?: string,
      where?: Where,
      limit?: number,
      page?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdGet(
        id,
        depth,
        locale,
        fallbackLocale,
        sort,
        where,
        limit,
        page,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Updates a User
     * @summary Updates a User
     * @param {string} id id of the User
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Users} [users]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersIdPatch(
      id: string,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      users?: Users,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersUpsertConfirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdPatch(
        id,
        depth,
        locale,
        fallbackLocale,
        users,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update all Users matching the where query
     * @summary Update multiple Users
     * @param {Where} where pass a where query to constrain returned documents (complex type, see documentation)
     * @param {string} [sort] sort by field
     * @param {number} [limit] limit the returned documents to a certain number
     * @param {number} [page] get a specific page of documents
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Users} [users]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersPatch(
      where: Where,
      sort?: string,
      limit?: number,
      page?: number,
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      users?: Users,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersDelete200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersPatch(
        where,
        sort,
        limit,
        page,
        depth,
        locale,
        fallbackLocale,
        users,
        options
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Create a new User
     * @summary Create a new User
     * @param {number} [depth] number of levels to automatically populate relationships and uploads
     * @param {string} [locale] retrieves document(s) in a specific locale
     * @param {string} [fallbackLocale] specifies a fallback locale if no locale value exists
     * @param {Users} [users]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usersPost(
      depth?: number,
      locale?: string,
      fallbackLocale?: string,
      users?: Users,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersUpsertConfirmation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(depth, locale, fallbackLocale, users, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = UsersApiFp(configuration)
  return {
    /**
     * Delete all Users matching the where query
     * @summary Delete multiple Users
     * @param {UsersApiUsersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersDelete(
      requestParameters: UsersApiUsersDeleteRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<UsersDelete200Response> {
      return localVarFp
        .usersDelete(
          requestParameters.where,
          requestParameters.sort,
          requestParameters.limit,
          requestParameters.page,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Find paginated Users
     * @summary Find paginated Users
     * @param {UsersApiUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersGet(requestParameters: UsersApiUsersGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Userss> {
      return localVarFp
        .usersGet(
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.sort,
          requestParameters.where,
          requestParameters.limit,
          requestParameters.page,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Deletes an existing User
     * @summary Deletes an existing User
     * @param {UsersApiUsersIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdDelete(
      requestParameters: UsersApiUsersIdDeleteRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<UsersUpsertConfirmation> {
      return localVarFp
        .usersIdDelete(
          requestParameters.id,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Get a single User by its id
     * @summary Get a single User by its id
     * @param {UsersApiUsersIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdGet(requestParameters: UsersApiUsersIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<Users> {
      return localVarFp
        .usersIdGet(
          requestParameters.id,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.sort,
          requestParameters.where,
          requestParameters.limit,
          requestParameters.page,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Updates a User
     * @summary Updates a User
     * @param {UsersApiUsersIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersIdPatch(
      requestParameters: UsersApiUsersIdPatchRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<UsersUpsertConfirmation> {
      return localVarFp
        .usersIdPatch(
          requestParameters.id,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.users,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Update all Users matching the where query
     * @summary Update multiple Users
     * @param {UsersApiUsersPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPatch(
      requestParameters: UsersApiUsersPatchRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<UsersDelete200Response> {
      return localVarFp
        .usersPatch(
          requestParameters.where,
          requestParameters.sort,
          requestParameters.limit,
          requestParameters.page,
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.users,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Create a new User
     * @summary Create a new User
     * @param {UsersApiUsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usersPost(
      requestParameters: UsersApiUsersPostRequest = {},
      options?: AxiosRequestConfig
    ): AxiosPromise<UsersUpsertConfirmation> {
      return localVarFp
        .usersPost(
          requestParameters.depth,
          requestParameters.locale,
          requestParameters.fallbackLocale,
          requestParameters.users,
          options
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for usersDelete operation in UsersApi.
 * @export
 * @interface UsersApiUsersDeleteRequest
 */
export interface UsersApiUsersDeleteRequest {
  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof UsersApiUsersDelete
   */
  readonly where: Where

  /**
   * sort by field
   * @type {string}
   * @memberof UsersApiUsersDelete
   */
  readonly sort?: string

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof UsersApiUsersDelete
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof UsersApiUsersDelete
   */
  readonly page?: number

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof UsersApiUsersDelete
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof UsersApiUsersDelete
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof UsersApiUsersDelete
   */
  readonly fallbackLocale?: string
}

/**
 * Request parameters for usersGet operation in UsersApi.
 * @export
 * @interface UsersApiUsersGetRequest
 */
export interface UsersApiUsersGetRequest {
  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof UsersApiUsersGet
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof UsersApiUsersGet
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof UsersApiUsersGet
   */
  readonly fallbackLocale?: string

  /**
   * sort by field
   * @type {string}
   * @memberof UsersApiUsersGet
   */
  readonly sort?: string

  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof UsersApiUsersGet
   */
  readonly where?: Where

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof UsersApiUsersGet
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof UsersApiUsersGet
   */
  readonly page?: number
}

/**
 * Request parameters for usersIdDelete operation in UsersApi.
 * @export
 * @interface UsersApiUsersIdDeleteRequest
 */
export interface UsersApiUsersIdDeleteRequest {
  /**
   * id of the User
   * @type {string}
   * @memberof UsersApiUsersIdDelete
   */
  readonly id: string

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof UsersApiUsersIdDelete
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof UsersApiUsersIdDelete
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof UsersApiUsersIdDelete
   */
  readonly fallbackLocale?: string
}

/**
 * Request parameters for usersIdGet operation in UsersApi.
 * @export
 * @interface UsersApiUsersIdGetRequest
 */
export interface UsersApiUsersIdGetRequest {
  /**
   * id of the User
   * @type {string}
   * @memberof UsersApiUsersIdGet
   */
  readonly id: string

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof UsersApiUsersIdGet
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof UsersApiUsersIdGet
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof UsersApiUsersIdGet
   */
  readonly fallbackLocale?: string

  /**
   * sort by field
   * @type {string}
   * @memberof UsersApiUsersIdGet
   */
  readonly sort?: string

  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof UsersApiUsersIdGet
   */
  readonly where?: Where

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof UsersApiUsersIdGet
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof UsersApiUsersIdGet
   */
  readonly page?: number
}

/**
 * Request parameters for usersIdPatch operation in UsersApi.
 * @export
 * @interface UsersApiUsersIdPatchRequest
 */
export interface UsersApiUsersIdPatchRequest {
  /**
   * id of the User
   * @type {string}
   * @memberof UsersApiUsersIdPatch
   */
  readonly id: string

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof UsersApiUsersIdPatch
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof UsersApiUsersIdPatch
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof UsersApiUsersIdPatch
   */
  readonly fallbackLocale?: string

  /**
   *
   * @type {Users}
   * @memberof UsersApiUsersIdPatch
   */
  readonly users?: Users
}

/**
 * Request parameters for usersPatch operation in UsersApi.
 * @export
 * @interface UsersApiUsersPatchRequest
 */
export interface UsersApiUsersPatchRequest {
  /**
   * pass a where query to constrain returned documents (complex type, see documentation)
   * @type {Where}
   * @memberof UsersApiUsersPatch
   */
  readonly where: Where

  /**
   * sort by field
   * @type {string}
   * @memberof UsersApiUsersPatch
   */
  readonly sort?: string

  /**
   * limit the returned documents to a certain number
   * @type {number}
   * @memberof UsersApiUsersPatch
   */
  readonly limit?: number

  /**
   * get a specific page of documents
   * @type {number}
   * @memberof UsersApiUsersPatch
   */
  readonly page?: number

  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof UsersApiUsersPatch
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof UsersApiUsersPatch
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof UsersApiUsersPatch
   */
  readonly fallbackLocale?: string

  /**
   *
   * @type {Users}
   * @memberof UsersApiUsersPatch
   */
  readonly users?: Users
}

/**
 * Request parameters for usersPost operation in UsersApi.
 * @export
 * @interface UsersApiUsersPostRequest
 */
export interface UsersApiUsersPostRequest {
  /**
   * number of levels to automatically populate relationships and uploads
   * @type {number}
   * @memberof UsersApiUsersPost
   */
  readonly depth?: number

  /**
   * retrieves document(s) in a specific locale
   * @type {string}
   * @memberof UsersApiUsersPost
   */
  readonly locale?: string

  /**
   * specifies a fallback locale if no locale value exists
   * @type {string}
   * @memberof UsersApiUsersPost
   */
  readonly fallbackLocale?: string

  /**
   *
   * @type {Users}
   * @memberof UsersApiUsersPost
   */
  readonly users?: Users
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * Delete all Users matching the where query
   * @summary Delete multiple Users
   * @param {UsersApiUsersDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersDelete(requestParameters: UsersApiUsersDeleteRequest, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .usersDelete(
        requestParameters.where,
        requestParameters.sort,
        requestParameters.limit,
        requestParameters.page,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Find paginated Users
   * @summary Find paginated Users
   * @param {UsersApiUsersGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersGet(requestParameters: UsersApiUsersGetRequest = {}, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .usersGet(
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.sort,
        requestParameters.where,
        requestParameters.limit,
        requestParameters.page,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Deletes an existing User
   * @summary Deletes an existing User
   * @param {UsersApiUsersIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersIdDelete(requestParameters: UsersApiUsersIdDeleteRequest, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .usersIdDelete(
        requestParameters.id,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get a single User by its id
   * @summary Get a single User by its id
   * @param {UsersApiUsersIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersIdGet(requestParameters: UsersApiUsersIdGetRequest, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .usersIdGet(
        requestParameters.id,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.sort,
        requestParameters.where,
        requestParameters.limit,
        requestParameters.page,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates a User
   * @summary Updates a User
   * @param {UsersApiUsersIdPatchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersIdPatch(requestParameters: UsersApiUsersIdPatchRequest, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .usersIdPatch(
        requestParameters.id,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.users,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update all Users matching the where query
   * @summary Update multiple Users
   * @param {UsersApiUsersPatchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersPatch(requestParameters: UsersApiUsersPatchRequest, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .usersPatch(
        requestParameters.where,
        requestParameters.sort,
        requestParameters.limit,
        requestParameters.page,
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.users,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create a new User
   * @summary Create a new User
   * @param {UsersApiUsersPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public usersPost(requestParameters: UsersApiUsersPostRequest = {}, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .usersPost(
        requestParameters.depth,
        requestParameters.locale,
        requestParameters.fallbackLocale,
        requestParameters.users,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }
}
